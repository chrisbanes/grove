# Grove CLI Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build the `grove` CLI tool that manages CoW-cloned workspaces with warm build caches from a golden copy repo.

**Architecture:** Go CLI using cobra. All state lives in `.grove/` within the repo. Platform-abstracted CoW cloning (`cp -c -R` on macOS, `cp --reflink=always` on Linux) behind a `Cloner` interface. Six internal packages: `config`, `git`, `clone`, `hooks`, `workspace`, `golden`. See `docs/DESIGN.md` for full design.

**Tech Stack:** Go 1.22+, `github.com/spf13/cobra` for CLI framework. No other external dependencies.

---

### Task 1: Go Module + Cobra Root Command

**Files:**
- Create: `go.mod`
- Create: `cmd/grove/main.go`

**Step 1: Initialize Go module**

Run:
```bash
cd /private/var/folders/_w/lwqygqhd6197zzpc53gzz4t80000gn/T/vibe-kanban/worktrees/9b7f-let-s-keep-brain/grove
go mod init github.com/AmpInc/grove
```

Expected: `go.mod` created.

**Step 2: Add cobra dependency**

Run:
```bash
go get github.com/spf13/cobra@latest
```

Expected: `go.mod` and `go.sum` updated.

**Step 3: Write the root command and main.go**

Create `cmd/grove/main.go`:

```go
package main

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
)

var version = "dev"

var rootCmd = &cobra.Command{
	Use:   "grove",
	Short: "Manage CoW-cloned workspaces with warm build caches",
	Long: `Grove creates copy-on-write clones of a "golden copy" repository,
preserving gitignored build state so every workspace starts with warm caches.`,
}

var versionCmd = &cobra.Command{
	Use:   "version",
	Short: "Print the grove version",
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Printf("grove %s\n", version)
	},
}

func main() {
	rootCmd.AddCommand(versionCmd)
	if err := rootCmd.Execute(); err != nil {
		os.Exit(1)
	}
}
```

**Step 4: Verify it builds and runs**

Run:
```bash
go build -o grove ./cmd/grove && ./grove version
```

Expected: `grove dev`

Run:
```bash
./grove --help
```

Expected: Help text with description and `version` subcommand listed.

**Step 5: Commit**

```bash
git add go.mod go.sum cmd/grove/main.go
git commit -m "feat: scaffold Go module with cobra root command"
```

---

### Task 2: Git Helper Package

**Files:**
- Create: `internal/git/git.go`
- Create: `internal/git/git_test.go`

**Step 1: Write the failing tests**

Create `internal/git/git_test.go`:

```go
package git_test

import (
	"os"
	"os/exec"
	"path/filepath"
	"testing"

	"github.com/AmpInc/grove/internal/git"
)

// helper to create a temp git repo
func setupRepo(t *testing.T) string {
	t.Helper()
	dir := t.TempDir()
	run(t, dir, "git", "init")
	run(t, dir, "git", "config", "user.email", "test@test.com")
	run(t, dir, "git", "config", "user.name", "Test")
	// Create initial commit so HEAD exists
	f := filepath.Join(dir, "README.md")
	os.WriteFile(f, []byte("# test"), 0644)
	run(t, dir, "git", "add", ".")
	run(t, dir, "git", "commit", "-m", "init")
	return dir
}

func run(t *testing.T, dir, name string, args ...string) {
	t.Helper()
	cmd := exec.Command(name, args...)
	cmd.Dir = dir
	out, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("%s %v failed: %s\n%s", name, args, err, out)
	}
}

func TestIsRepo(t *testing.T) {
	repo := setupRepo(t)
	if !git.IsRepo(repo) {
		t.Error("expected true for git repo")
	}
	if git.IsRepo(t.TempDir()) {
		t.Error("expected false for non-repo dir")
	}
}

func TestIsDirty_Clean(t *testing.T) {
	repo := setupRepo(t)
	dirty, err := git.IsDirty(repo)
	if err != nil {
		t.Fatal(err)
	}
	if dirty {
		t.Error("expected clean repo")
	}
}

func TestIsDirty_Dirty(t *testing.T) {
	repo := setupRepo(t)
	os.WriteFile(filepath.Join(repo, "new.txt"), []byte("change"), 0644)
	dirty, err := git.IsDirty(repo)
	if err != nil {
		t.Fatal(err)
	}
	if !dirty {
		t.Error("expected dirty repo")
	}
}

func TestCurrentBranch(t *testing.T) {
	repo := setupRepo(t)
	branch, err := git.CurrentBranch(repo)
	if err != nil {
		t.Fatal(err)
	}
	// git init creates "main" or "master" depending on config
	if branch == "" {
		t.Error("expected non-empty branch")
	}
}

func TestCurrentCommit(t *testing.T) {
	repo := setupRepo(t)
	commit, err := git.CurrentCommit(repo)
	if err != nil {
		t.Fatal(err)
	}
	if len(commit) < 7 {
		t.Errorf("expected short hash, got %q", commit)
	}
}

func TestCheckout_NewBranch(t *testing.T) {
	repo := setupRepo(t)
	err := git.Checkout(repo, "feature/test", true)
	if err != nil {
		t.Fatal(err)
	}
	branch, _ := git.CurrentBranch(repo)
	if branch != "feature/test" {
		t.Errorf("expected feature/test, got %s", branch)
	}
}
```

**Step 2: Run tests to verify they fail**

Run:
```bash
go test ./internal/git/... -v
```

Expected: compilation errors — `git` package doesn't exist yet.

**Step 3: Write the implementation**

Create `internal/git/git.go`:

```go
package git

import (
	"os/exec"
	"strings"
)

// IsRepo returns true if path is inside a git repository.
func IsRepo(path string) bool {
	cmd := exec.Command("git", "-C", path, "rev-parse", "--git-dir")
	return cmd.Run() == nil
}

// IsDirty returns true if the repo at path has uncommitted changes
// (staged or unstaged, including untracked files).
func IsDirty(path string) (bool, error) {
	cmd := exec.Command("git", "-C", path, "status", "--porcelain")
	out, err := cmd.Output()
	if err != nil {
		return false, err
	}
	return strings.TrimSpace(string(out)) != "", nil
}

// CurrentBranch returns the current branch name.
func CurrentBranch(path string) (string, error) {
	cmd := exec.Command("git", "-C", path, "branch", "--show-current")
	out, err := cmd.Output()
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(string(out)), nil
}

// CurrentCommit returns the short hash of HEAD.
func CurrentCommit(path string) (string, error) {
	cmd := exec.Command("git", "-C", path, "rev-parse", "--short", "HEAD")
	out, err := cmd.Output()
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(string(out)), nil
}

// Pull runs git pull in the repo at path.
func Pull(path string) error {
	cmd := exec.Command("git", "-C", path, "pull")
	cmd.Stdout = nil
	cmd.Stderr = nil
	return cmd.Run()
}

// Checkout switches to a branch. If create is true, creates it with -b.
func Checkout(path, branch string, create bool) error {
	args := []string{"-C", path, "checkout"}
	if create {
		args = append(args, "-b")
	}
	args = append(args, branch)
	cmd := exec.Command("git", args...)
	return cmd.Run()
}

// RepoRoot returns the root directory of the git repo containing path.
func RepoRoot(path string) (string, error) {
	cmd := exec.Command("git", "-C", path, "rev-parse", "--show-toplevel")
	out, err := cmd.Output()
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(string(out)), nil
}
```

**Step 4: Run tests to verify they pass**

Run:
```bash
go test ./internal/git/... -v
```

Expected: all tests PASS.

**Step 5: Commit**

```bash
git add internal/git/
git commit -m "feat: add git helper package with tests"
```

---

### Task 3: Config Package

**Files:**
- Create: `internal/config/config.go`
- Create: `internal/config/config_test.go`

**Step 1: Write the failing tests**

Create `internal/config/config_test.go`:

```go
package config_test

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/AmpInc/grove/internal/config"
)

func TestDefaultConfig(t *testing.T) {
	cfg := config.DefaultConfig("myapp")
	if cfg.MaxWorkspaces != 10 {
		t.Errorf("expected max_workspaces 10, got %d", cfg.MaxWorkspaces)
	}
	if cfg.WorkspaceDir == "" {
		t.Error("expected non-empty workspace_dir")
	}
}

func TestSaveAndLoad(t *testing.T) {
	dir := t.TempDir()
	groveDir := filepath.Join(dir, ".grove")
	os.MkdirAll(groveDir, 0755)

	cfg := &config.Config{
		WarmupCommand: "make build",
		WorkspaceDir:  "/tmp/grove/test",
		MaxWorkspaces: 5,
	}
	err := config.Save(dir, cfg)
	if err != nil {
		t.Fatal(err)
	}

	loaded, err := config.Load(dir)
	if err != nil {
		t.Fatal(err)
	}
	if loaded.WarmupCommand != "make build" {
		t.Errorf("expected 'make build', got %q", loaded.WarmupCommand)
	}
	if loaded.MaxWorkspaces != 5 {
		t.Errorf("expected 5, got %d", loaded.MaxWorkspaces)
	}
}

func TestLoad_Defaults(t *testing.T) {
	dir := t.TempDir()
	groveDir := filepath.Join(dir, ".grove")
	os.MkdirAll(groveDir, 0755)

	// Write minimal config missing optional fields
	os.WriteFile(
		filepath.Join(groveDir, "config.json"),
		[]byte(`{"workspace_dir": "/tmp/test"}`),
		0644,
	)

	cfg, err := config.Load(dir)
	if err != nil {
		t.Fatal(err)
	}
	if cfg.MaxWorkspaces != 10 {
		t.Errorf("expected default max_workspaces 10, got %d", cfg.MaxWorkspaces)
	}
}

func TestLoad_NotInitialized(t *testing.T) {
	dir := t.TempDir()
	_, err := config.Load(dir)
	if err == nil {
		t.Error("expected error for non-initialized repo")
	}
}

func TestExpandWorkspaceDir(t *testing.T) {
	cfg := config.DefaultConfig("myapp")
	expanded := config.ExpandWorkspaceDir(cfg.WorkspaceDir, "myapp")
	if expanded == cfg.WorkspaceDir {
		t.Error("expected {project} to be expanded")
	}
	if filepath.Base(expanded) != "myapp" {
		t.Errorf("expected 'myapp' in path, got %q", expanded)
	}
}

func TestFindRepoRoot(t *testing.T) {
	dir := t.TempDir()
	groveDir := filepath.Join(dir, ".grove")
	os.MkdirAll(groveDir, 0755)
	subDir := filepath.Join(dir, "sub", "deep")
	os.MkdirAll(subDir, 0755)

	root, err := config.FindGroveRoot(subDir)
	if err != nil {
		t.Fatal(err)
	}
	if root != dir {
		t.Errorf("expected %s, got %s", dir, root)
	}
}

func TestFindRepoRoot_NotFound(t *testing.T) {
	dir := t.TempDir()
	_, err := config.FindGroveRoot(dir)
	if err == nil {
		t.Error("expected error when no .grove found")
	}
}
```

**Step 2: Run tests to verify they fail**

Run:
```bash
go test ./internal/config/... -v
```

Expected: compilation errors — `config` package doesn't exist yet.

**Step 3: Write the implementation**

Create `internal/config/config.go`:

```go
package config

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

const (
	GroveDirName  = ".grove"
	ConfigFile    = "config.json"
	WorkspaceFile = "workspace.json"
	HooksDir      = "hooks"
)

type Config struct {
	WarmupCommand string `json:"warmup_command,omitempty"`
	WorkspaceDir  string `json:"workspace_dir"`
	MaxWorkspaces int    `json:"max_workspaces"`
}

// DefaultConfig returns a config with sensible defaults.
func DefaultConfig(projectName string) *Config {
	return &Config{
		WorkspaceDir:  "/tmp/grove/{project}",
		MaxWorkspaces: 10,
	}
}

// Load reads .grove/config.json from repoRoot and applies defaults
// for missing fields.
func Load(repoRoot string) (*Config, error) {
	path := filepath.Join(repoRoot, GroveDirName, ConfigFile)
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("grove not initialized: %w", err)
	}
	var cfg Config
	if err := json.Unmarshal(data, &cfg); err != nil {
		return nil, fmt.Errorf("invalid config: %w", err)
	}
	// Apply defaults
	if cfg.MaxWorkspaces == 0 {
		cfg.MaxWorkspaces = 10
	}
	return &cfg, nil
}

// Save writes config to .grove/config.json.
func Save(repoRoot string, cfg *Config) error {
	groveDir := filepath.Join(repoRoot, GroveDirName)
	if err := os.MkdirAll(groveDir, 0755); err != nil {
		return err
	}
	data, err := json.MarshalIndent(cfg, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(filepath.Join(groveDir, ConfigFile), data, 0644)
}

// ExpandWorkspaceDir replaces {project} in the workspace dir template.
func ExpandWorkspaceDir(tmpl, projectName string) string {
	return strings.ReplaceAll(tmpl, "{project}", projectName)
}

// FindGroveRoot walks up from startPath looking for a .grove/ directory.
// Returns the directory containing .grove/, or an error if not found.
func FindGroveRoot(startPath string) (string, error) {
	absPath, err := filepath.Abs(startPath)
	if err != nil {
		return "", err
	}
	dir := absPath
	for {
		candidate := filepath.Join(dir, GroveDirName)
		if info, err := os.Stat(candidate); err == nil && info.IsDir() {
			return dir, nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			return "", fmt.Errorf("grove not initialized: no .grove/ directory found above %s", startPath)
		}
		dir = parent
	}
}
```

**Step 4: Run tests to verify they pass**

Run:
```bash
go test ./internal/config/... -v
```

Expected: all tests PASS.

**Step 5: Commit**

```bash
git add internal/config/
git commit -m "feat: add config package with load/save/defaults"
```

---

### Task 4: CoW Clone Package — Interface + APFS Implementation

**Files:**
- Create: `internal/clone/clone.go`
- Create: `internal/clone/apfs.go`
- Create: `internal/clone/detect.go`
- Create: `internal/clone/clone_test.go`

**Step 1: Write the failing tests**

Create `internal/clone/clone_test.go`:

```go
package clone_test

import (
	"os"
	"path/filepath"
	"runtime"
	"testing"

	"github.com/AmpInc/grove/internal/clone"
)

func TestNewCloner_ReturnsCloner(t *testing.T) {
	if runtime.GOOS != "darwin" {
		t.Skip("APFS tests only run on macOS")
	}
	dir := t.TempDir()
	c, err := clone.NewCloner(dir)
	if err != nil {
		t.Fatalf("expected cloner on macOS/APFS, got error: %v", err)
	}
	if c == nil {
		t.Fatal("expected non-nil cloner")
	}
}

func TestClone_CopiesAllFiles(t *testing.T) {
	if runtime.GOOS != "darwin" {
		t.Skip("APFS tests only run on macOS")
	}

	src := t.TempDir()
	// Create a directory structure with files
	os.MkdirAll(filepath.Join(src, "sub", "deep"), 0755)
	os.WriteFile(filepath.Join(src, "root.txt"), []byte("root"), 0644)
	os.WriteFile(filepath.Join(src, "sub", "mid.txt"), []byte("mid"), 0644)
	os.WriteFile(filepath.Join(src, "sub", "deep", "leaf.txt"), []byte("leaf"), 0644)

	dst := filepath.Join(t.TempDir(), "clone")

	c, err := clone.NewCloner(src)
	if err != nil {
		t.Fatal(err)
	}
	if err := c.Clone(src, dst); err != nil {
		t.Fatal(err)
	}

	// Verify all files exist in clone
	for _, rel := range []string{"root.txt", "sub/mid.txt", "sub/deep/leaf.txt"} {
		data, err := os.ReadFile(filepath.Join(dst, rel))
		if err != nil {
			t.Errorf("missing file %s: %v", rel, err)
			continue
		}
		expected := filepath.Base(rel)
		expected = expected[:len(expected)-len(filepath.Ext(expected))]
		if string(data) != expected {
			t.Errorf("file %s: expected %q, got %q", rel, expected, string(data))
		}
	}
}

func TestClone_CopyOnWrite(t *testing.T) {
	if runtime.GOOS != "darwin" {
		t.Skip("APFS tests only run on macOS")
	}

	src := t.TempDir()
	os.WriteFile(filepath.Join(src, "file.txt"), []byte("original"), 0644)

	dst := filepath.Join(t.TempDir(), "clone")

	c, _ := clone.NewCloner(src)
	c.Clone(src, dst)

	// Modify the clone
	os.WriteFile(filepath.Join(dst, "file.txt"), []byte("modified"), 0644)

	// Source should be unchanged
	data, _ := os.ReadFile(filepath.Join(src, "file.txt"))
	if string(data) != "original" {
		t.Error("source was modified — CoW isolation broken")
	}
}

func TestClone_HiddenFiles(t *testing.T) {
	if runtime.GOOS != "darwin" {
		t.Skip("APFS tests only run on macOS")
	}

	src := t.TempDir()
	os.MkdirAll(filepath.Join(src, ".hidden"), 0755)
	os.WriteFile(filepath.Join(src, ".hidden", "secret.txt"), []byte("secret"), 0644)
	os.WriteFile(filepath.Join(src, ".dotfile"), []byte("dot"), 0644)

	dst := filepath.Join(t.TempDir(), "clone")

	c, _ := clone.NewCloner(src)
	c.Clone(src, dst)

	if _, err := os.Stat(filepath.Join(dst, ".hidden", "secret.txt")); err != nil {
		t.Error("hidden directory not cloned")
	}
	if _, err := os.Stat(filepath.Join(dst, ".dotfile")); err != nil {
		t.Error("dotfile not cloned")
	}
}
```

**Step 2: Run tests to verify they fail**

Run:
```bash
go test ./internal/clone/... -v
```

Expected: compilation errors — `clone` package doesn't exist yet.

**Step 3: Write the implementation**

Create `internal/clone/clone.go`:

```go
package clone

// Cloner performs copy-on-write directory clones.
type Cloner interface {
	// Clone performs a CoW clone from src to dst.
	Clone(src, dst string) error
}
```

Create `internal/clone/apfs.go`:

```go
package clone

import (
	"fmt"
	"os/exec"
	"runtime"
)

// APFSCloner performs CoW clones using macOS APFS cp -c.
type APFSCloner struct{}

func (c *APFSCloner) Clone(src, dst string) error {
	cmd := exec.Command("cp", "-c", "-R", src, dst)
	out, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("apfs clone failed: %w\n%s", err, out)
	}
	return nil
}

// isAPFS checks if the filesystem at path is APFS.
func isAPFS(path string) (bool, error) {
	if runtime.GOOS != "darwin" {
		return false, nil
	}
	// Use diskutil to check the filesystem type for the volume
	// containing path. We use `df` to find the mount point first.
	dfCmd := exec.Command("df", path)
	dfOut, err := dfCmd.Output()
	if err != nil {
		return false, fmt.Errorf("df failed: %w", err)
	}
	// df output: last line, first field is the device
	lines := splitLines(string(dfOut))
	if len(lines) < 2 {
		return false, fmt.Errorf("unexpected df output")
	}
	// Parse the mount point from the last column of the last line
	fields := splitFields(lines[len(lines)-1])
	if len(fields) < 1 {
		return false, fmt.Errorf("unexpected df output format")
	}
	mountPoint := fields[len(fields)-1]

	diskutilCmd := exec.Command("diskutil", "info", mountPoint)
	diskutilOut, err := diskutilCmd.Output()
	if err != nil {
		return false, fmt.Errorf("diskutil failed: %w", err)
	}
	return containsString(string(diskutilOut), "APFS"), nil
}
```

Create `internal/clone/detect.go`:

```go
package clone

import (
	"fmt"
	"runtime"
	"strings"
)

// NewCloner returns the appropriate Cloner for the current platform
// and filesystem. Returns an error if CoW is not supported.
func NewCloner(path string) (Cloner, error) {
	switch runtime.GOOS {
	case "darwin":
		ok, err := isAPFS(path)
		if err != nil {
			return nil, fmt.Errorf("filesystem detection failed: %w", err)
		}
		if !ok {
			return nil, fmt.Errorf(
				"filesystem at %s does not support copy-on-write clones.\n"+
					"Grove requires APFS (macOS) or Btrfs/XFS with reflink support (Linux)", path)
		}
		return &APFSCloner{}, nil
	case "linux":
		return nil, fmt.Errorf("linux reflink support not yet implemented")
	default:
		return nil, fmt.Errorf("unsupported platform: %s", runtime.GOOS)
	}
}

// helper functions

func splitLines(s string) []string {
	lines := strings.Split(strings.TrimSpace(s), "\n")
	var result []string
	for _, l := range lines {
		if l != "" {
			result = append(result, l)
		}
	}
	return result
}

func splitFields(s string) []string {
	return strings.Fields(s)
}

func containsString(haystack, needle string) bool {
	return strings.Contains(haystack, needle)
}
```

**Step 4: Run tests to verify they pass**

Run:
```bash
go test ./internal/clone/... -v
```

Expected: all tests PASS (on macOS with APFS).

**Step 5: Commit**

```bash
git add internal/clone/
git commit -m "feat: add CoW clone package with APFS implementation"
```

---

### Task 5: Hooks Package

**Files:**
- Create: `internal/hooks/hooks.go`
- Create: `internal/hooks/hooks_test.go`

**Step 1: Write the failing tests**

Create `internal/hooks/hooks_test.go`:

```go
package hooks_test

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/AmpInc/grove/internal/hooks"
)

func TestRun_HookExists(t *testing.T) {
	dir := t.TempDir()
	hooksDir := filepath.Join(dir, ".grove", "hooks")
	os.MkdirAll(hooksDir, 0755)

	// Create a hook that writes a marker file
	hookPath := filepath.Join(hooksDir, "post-clone")
	os.WriteFile(hookPath, []byte("#!/bin/bash\ntouch \"$PWD/hook-ran\"\n"), 0755)

	err := hooks.Run(dir, "post-clone")
	if err != nil {
		t.Fatal(err)
	}

	if _, err := os.Stat(filepath.Join(dir, "hook-ran")); err != nil {
		t.Error("hook did not execute")
	}
}

func TestRun_HookMissing(t *testing.T) {
	dir := t.TempDir()
	os.MkdirAll(filepath.Join(dir, ".grove", "hooks"), 0755)

	// Should succeed silently — hooks are optional
	err := hooks.Run(dir, "post-clone")
	if err != nil {
		t.Errorf("expected no error for missing hook, got: %v", err)
	}
}

func TestRun_HookFails(t *testing.T) {
	dir := t.TempDir()
	hooksDir := filepath.Join(dir, ".grove", "hooks")
	os.MkdirAll(hooksDir, 0755)

	hookPath := filepath.Join(hooksDir, "post-clone")
	os.WriteFile(hookPath, []byte("#!/bin/bash\nexit 1\n"), 0755)

	err := hooks.Run(dir, "post-clone")
	if err == nil {
		t.Error("expected error for failing hook")
	}
}

func TestRun_HookNotExecutable(t *testing.T) {
	dir := t.TempDir()
	hooksDir := filepath.Join(dir, ".grove", "hooks")
	os.MkdirAll(hooksDir, 0755)

	hookPath := filepath.Join(hooksDir, "post-clone")
	os.WriteFile(hookPath, []byte("#!/bin/bash\necho ok\n"), 0644) // not executable

	err := hooks.Run(dir, "post-clone")
	if err == nil {
		t.Error("expected error for non-executable hook")
	}
}
```

**Step 2: Run tests to verify they fail**

Run:
```bash
go test ./internal/hooks/... -v
```

Expected: compilation errors — `hooks` package doesn't exist yet.

**Step 3: Write the implementation**

Create `internal/hooks/hooks.go`:

```go
package hooks

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
)

// Run executes the named hook from the .grove/hooks/ directory within
// repoRoot. The hook runs with its working directory set to repoRoot.
// If the hook doesn't exist, Run returns nil (hooks are optional).
// If the hook exists but is not executable, Run returns an error.
func Run(repoRoot, hookName string) error {
	hookPath := filepath.Join(repoRoot, ".grove", "hooks", hookName)

	info, err := os.Stat(hookPath)
	if os.IsNotExist(err) {
		return nil // hooks are optional
	}
	if err != nil {
		return fmt.Errorf("checking hook %s: %w", hookName, err)
	}

	// Check executable bit
	if info.Mode()&0111 == 0 {
		return fmt.Errorf("hook %s exists but is not executable: chmod +x %s", hookName, hookPath)
	}

	cmd := exec.Command(hookPath)
	cmd.Dir = repoRoot
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("hook %s failed: %w", hookName, err)
	}
	return nil
}
```

**Step 4: Run tests to verify they pass**

Run:
```bash
go test ./internal/hooks/... -v
```

Expected: all tests PASS.

**Step 5: Commit**

```bash
git add internal/hooks/
git commit -m "feat: add hooks package for post-clone lifecycle scripts"
```

---

### Task 6: Workspace Package

**Files:**
- Create: `internal/workspace/workspace.go`
- Create: `internal/workspace/workspace_test.go`

**Step 1: Write the failing tests**

Create `internal/workspace/workspace_test.go`:

```go
package workspace_test

import (
	"os"
	"path/filepath"
	"runtime"
	"testing"

	"github.com/AmpInc/grove/internal/clone"
	"github.com/AmpInc/grove/internal/config"
	"github.com/AmpInc/grove/internal/workspace"
)

func setupGolden(t *testing.T) (string, *config.Config) {
	t.Helper()
	dir := t.TempDir()
	os.MkdirAll(filepath.Join(dir, ".grove", "hooks"), 0755)
	os.WriteFile(filepath.Join(dir, "src.txt"), []byte("source"), 0644)

	wsDir := filepath.Join(t.TempDir(), "workspaces")
	cfg := &config.Config{
		WorkspaceDir:  wsDir,
		MaxWorkspaces: 3,
	}
	config.Save(dir, cfg)
	return dir, cfg
}

func TestCreate(t *testing.T) {
	if runtime.GOOS != "darwin" {
		t.Skip("APFS tests only run on macOS")
	}
	golden, cfg := setupGolden(t)
	c, _ := clone.NewCloner(golden)

	info, err := workspace.Create(golden, cfg, c, workspace.CreateOpts{})
	if err != nil {
		t.Fatal(err)
	}

	if info.ID == "" {
		t.Error("expected non-empty ID")
	}
	if info.Path == "" {
		t.Error("expected non-empty Path")
	}

	// Verify source file was cloned
	data, err := os.ReadFile(filepath.Join(info.Path, "src.txt"))
	if err != nil {
		t.Fatal(err)
	}
	if string(data) != "source" {
		t.Errorf("expected 'source', got %q", string(data))
	}

	// Verify workspace marker exists
	if !workspace.IsWorkspace(info.Path) {
		t.Error("expected workspace marker to exist")
	}
}

func TestCreate_MaxWorkspaces(t *testing.T) {
	if runtime.GOOS != "darwin" {
		t.Skip("APFS tests only run on macOS")
	}
	golden, cfg := setupGolden(t)
	cfg.MaxWorkspaces = 2
	c, _ := clone.NewCloner(golden)

	workspace.Create(golden, cfg, c, workspace.CreateOpts{})
	workspace.Create(golden, cfg, c, workspace.CreateOpts{})
	_, err := workspace.Create(golden, cfg, c, workspace.CreateOpts{})
	if err == nil {
		t.Error("expected error when exceeding max workspaces")
	}
}

func TestList(t *testing.T) {
	if runtime.GOOS != "darwin" {
		t.Skip("APFS tests only run on macOS")
	}
	golden, cfg := setupGolden(t)
	c, _ := clone.NewCloner(golden)

	workspace.Create(golden, cfg, c, workspace.CreateOpts{})
	workspace.Create(golden, cfg, c, workspace.CreateOpts{})

	list, err := workspace.List(cfg)
	if err != nil {
		t.Fatal(err)
	}
	if len(list) != 2 {
		t.Errorf("expected 2 workspaces, got %d", len(list))
	}
}

func TestDestroy(t *testing.T) {
	if runtime.GOOS != "darwin" {
		t.Skip("APFS tests only run on macOS")
	}
	golden, cfg := setupGolden(t)
	c, _ := clone.NewCloner(golden)

	info, _ := workspace.Create(golden, cfg, c, workspace.CreateOpts{})
	err := workspace.Destroy(cfg, info.ID)
	if err != nil {
		t.Fatal(err)
	}
	if _, err := os.Stat(info.Path); !os.IsNotExist(err) {
		t.Error("workspace directory should be deleted")
	}

	list, _ := workspace.List(cfg)
	if len(list) != 0 {
		t.Errorf("expected 0 workspaces after destroy, got %d", len(list))
	}
}

func TestIsWorkspace(t *testing.T) {
	dir := t.TempDir()
	if workspace.IsWorkspace(dir) {
		t.Error("expected false for non-workspace")
	}

	os.MkdirAll(filepath.Join(dir, ".grove"), 0755)
	os.WriteFile(filepath.Join(dir, ".grove", "workspace.json"), []byte("{}"), 0644)
	if !workspace.IsWorkspace(dir) {
		t.Error("expected true for workspace with marker")
	}
}
```

**Step 2: Run tests to verify they fail**

Run:
```bash
go test ./internal/workspace/... -v
```

Expected: compilation errors — `workspace` package doesn't exist yet.

**Step 3: Write the implementation**

Create `internal/workspace/workspace.go`:

```go
package workspace

import (
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/AmpInc/grove/internal/clone"
	"github.com/AmpInc/grove/internal/config"
)

type Info struct {
	ID           string    `json:"id"`
	GoldenCopy   string    `json:"golden_copy"`
	GoldenCommit string    `json:"golden_commit"`
	CreatedAt    time.Time `json:"created_at"`
	Branch       string    `json:"branch"`
	Path         string    `json:"path"`
}

type CreateOpts struct {
	Branch       string
	GoldenCommit string
}

// Create makes a new workspace by CoW-cloning the golden copy.
func Create(goldenRoot string, cfg *config.Config, cloner clone.Cloner, opts CreateOpts) (*Info, error) {
	// Check max workspace limit
	existing, err := List(cfg)
	if err != nil && !os.IsNotExist(err) {
		return nil, err
	}
	if len(existing) >= cfg.MaxWorkspaces {
		return nil, fmt.Errorf("max workspaces (%d) reached — destroy one first", cfg.MaxWorkspaces)
	}

	id, err := generateID()
	if err != nil {
		return nil, fmt.Errorf("generating workspace ID: %w", err)
	}

	wsPath := filepath.Join(cfg.WorkspaceDir, id)

	// Ensure parent directory exists
	if err := os.MkdirAll(cfg.WorkspaceDir, 0755); err != nil {
		return nil, fmt.Errorf("creating workspace directory: %w", err)
	}

	// CoW clone
	if err := cloner.Clone(goldenRoot, wsPath); err != nil {
		os.RemoveAll(wsPath) // clean up partial clone
		return nil, fmt.Errorf("clone failed: %w", err)
	}

	info := &Info{
		ID:           id,
		GoldenCopy:   goldenRoot,
		GoldenCommit: opts.GoldenCommit,
		CreatedAt:    time.Now().UTC(),
		Branch:       opts.Branch,
		Path:         wsPath,
	}

	// Write workspace marker
	if err := writeMarker(wsPath, info); err != nil {
		os.RemoveAll(wsPath)
		return nil, fmt.Errorf("writing workspace marker: %w", err)
	}

	return info, nil
}

// List returns all workspaces in the configured workspace directory.
func List(cfg *config.Config) ([]Info, error) {
	entries, err := os.ReadDir(cfg.WorkspaceDir)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil
		}
		return nil, err
	}

	var workspaces []Info
	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}
		wsPath := filepath.Join(cfg.WorkspaceDir, entry.Name())
		info, err := readMarker(wsPath)
		if err != nil {
			continue // skip directories without valid markers
		}
		info.Path = wsPath
		workspaces = append(workspaces, *info)
	}
	return workspaces, nil
}

// Destroy removes a workspace by ID or path.
func Destroy(cfg *config.Config, idOrPath string) error {
	wsPath, err := resolveWorkspace(cfg, idOrPath)
	if err != nil {
		return err
	}
	return os.RemoveAll(wsPath)
}

// Get returns info for a workspace by ID or path.
func Get(cfg *config.Config, idOrPath string) (*Info, error) {
	wsPath, err := resolveWorkspace(cfg, idOrPath)
	if err != nil {
		return nil, err
	}
	info, err := readMarker(wsPath)
	if err != nil {
		return nil, err
	}
	info.Path = wsPath
	return info, nil
}

// IsWorkspace returns true if path contains a .grove/workspace.json marker.
func IsWorkspace(path string) bool {
	_, err := os.Stat(filepath.Join(path, ".grove", config.WorkspaceFile))
	return err == nil
}

// resolveWorkspace finds a workspace path from an ID or path.
func resolveWorkspace(cfg *config.Config, idOrPath string) (string, error) {
	// Try as direct path
	if filepath.IsAbs(idOrPath) {
		if IsWorkspace(idOrPath) {
			return idOrPath, nil
		}
		return "", fmt.Errorf("not a grove workspace: %s", idOrPath)
	}
	// Try as ID
	wsPath := filepath.Join(cfg.WorkspaceDir, idOrPath)
	if IsWorkspace(wsPath) {
		return wsPath, nil
	}
	return "", fmt.Errorf("workspace not found: %s", idOrPath)
}

func writeMarker(wsPath string, info *Info) error {
	data, err := json.MarshalIndent(info, "", "  ")
	if err != nil {
		return err
	}
	markerPath := filepath.Join(wsPath, ".grove", config.WorkspaceFile)
	return os.WriteFile(markerPath, data, 0644)
}

func readMarker(wsPath string) (*Info, error) {
	data, err := os.ReadFile(filepath.Join(wsPath, ".grove", config.WorkspaceFile))
	if err != nil {
		return nil, err
	}
	var info Info
	if err := json.Unmarshal(data, &info); err != nil {
		return nil, err
	}
	return &info, nil
}

func generateID() (string, error) {
	bytes := make([]byte, 4)
	if _, err := rand.Read(bytes); err != nil {
		return "", err
	}
	return hex.EncodeToString(bytes), nil
}
```

**Step 4: Run tests to verify they pass**

Run:
```bash
go test ./internal/workspace/... -v
```

Expected: all tests PASS.

**Step 5: Commit**

```bash
git add internal/workspace/
git commit -m "feat: add workspace package with create/list/destroy/get"
```

---

### Task 7: `grove init` Command

**Files:**
- Create: `cmd/grove/init.go`

**Step 1: Write the init command**

Create `cmd/grove/init.go`:

```go
package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"

	"github.com/AmpInc/grove/internal/config"
	gitpkg "github.com/AmpInc/grove/internal/git"
	"github.com/spf13/cobra"
)

var initCmd = &cobra.Command{
	Use:   "init [path]",
	Short: "Initialize a golden copy from an existing repo",
	Long: `Registers a git repository as a grove-managed golden copy.
Creates a .grove/ directory with config and optional hooks.`,
	Args: cobra.MaximumNArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		path := "."
		if len(args) > 0 {
			path = args[0]
		}
		absPath, err := filepath.Abs(path)
		if err != nil {
			return err
		}

		// Verify it's a git repo
		if !gitpkg.IsRepo(absPath) {
			return fmt.Errorf("%s is not a git repository", absPath)
		}

		// Check for existing .grove
		groveDir := filepath.Join(absPath, config.GroveDirName)
		if _, err := os.Stat(groveDir); err == nil {
			return fmt.Errorf("grove already initialized at %s", absPath)
		}

		// Check for uncommitted changes
		force, _ := cmd.Flags().GetBool("force")
		dirty, err := gitpkg.IsDirty(absPath)
		if err != nil {
			return fmt.Errorf("checking repo status: %w", err)
		}
		if dirty && !force {
			return fmt.Errorf(
				"golden copy has uncommitted changes.\n" +
					"These changes will be included in workspace clones.\n" +
					"Use --force to proceed anyway")
		}

		// Create .grove directory structure
		if err := os.MkdirAll(filepath.Join(groveDir, config.HooksDir), 0755); err != nil {
			return err
		}

		// Write default config
		projectName := filepath.Base(absPath)
		cfg := config.DefaultConfig(projectName)

		warmupCmd, _ := cmd.Flags().GetString("warmup-command")
		if warmupCmd != "" {
			cfg.WarmupCommand = warmupCmd
		}
		wsDir, _ := cmd.Flags().GetString("workspace-dir")
		if wsDir != "" {
			cfg.WorkspaceDir = wsDir
		}

		if err := config.Save(absPath, cfg); err != nil {
			return fmt.Errorf("saving config: %w", err)
		}

		// Run warmup command if configured
		if cfg.WarmupCommand != "" {
			fmt.Printf("Running warmup: %s\n", cfg.WarmupCommand)
			warmup := exec.Command("sh", "-c", cfg.WarmupCommand)
			warmup.Dir = absPath
			warmup.Stdout = os.Stdout
			warmup.Stderr = os.Stderr
			if err := warmup.Run(); err != nil {
				return fmt.Errorf("warmup command failed: %w", err)
			}
		}

		fmt.Printf("Grove initialized at %s\n", absPath)
		fmt.Printf("Workspace dir: %s\n", config.ExpandWorkspaceDir(cfg.WorkspaceDir, projectName))
		return nil
	},
}

func init() {
	initCmd.Flags().String("warmup-command", "", "Command to run for warming up build caches")
	initCmd.Flags().String("workspace-dir", "", "Directory for workspaces (default: /tmp/grove/{project})")
	initCmd.Flags().Bool("force", false, "Proceed even if golden copy has uncommitted changes")
	rootCmd.AddCommand(initCmd)
}
```

**Step 2: Build and test manually**

Run:
```bash
go build -o grove ./cmd/grove
```

Expected: builds without errors.

Run (in a temp git repo):
```bash
cd $(mktemp -d) && git init && git commit --allow-empty -m "init"
/path/to/grove init
```

Expected: "Grove initialized at ..." message, `.grove/config.json` created.

**Step 3: Commit**

```bash
git add cmd/grove/init.go
git commit -m "feat: add grove init command"
```

---

### Task 8: `grove create` Command

**Files:**
- Create: `cmd/grove/create.go`

**Step 1: Write the create command**

Create `cmd/grove/create.go`:

```go
package main

import (
	"encoding/json"
	"fmt"
	"os"

	"github.com/AmpInc/grove/internal/clone"
	"github.com/AmpInc/grove/internal/config"
	gitpkg "github.com/AmpInc/grove/internal/git"
	"github.com/AmpInc/grove/internal/hooks"
	"github.com/AmpInc/grove/internal/workspace"
	"github.com/spf13/cobra"
)

var createCmd = &cobra.Command{
	Use:   "create",
	Short: "Create a new workspace from the golden copy",
	Long: `Creates a copy-on-write clone of the golden copy, including all build
caches and gitignored files. Builds in the workspace start warm.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		cwd, err := os.Getwd()
		if err != nil {
			return err
		}

		goldenRoot, err := config.FindGroveRoot(cwd)
		if err != nil {
			return err
		}

		// Don't allow creating workspaces from within a workspace
		if workspace.IsWorkspace(goldenRoot) {
			return fmt.Errorf("cannot create a workspace from inside another workspace.\nRun this from the golden copy instead")
		}

		cfg, err := config.Load(goldenRoot)
		if err != nil {
			return err
		}

		// Expand workspace dir
		projectName := getProjectName(goldenRoot)
		cfg.WorkspaceDir = config.ExpandWorkspaceDir(cfg.WorkspaceDir, projectName)

		// Check for uncommitted changes
		force, _ := cmd.Flags().GetBool("force")
		dirty, err := gitpkg.IsDirty(goldenRoot)
		if err != nil {
			return fmt.Errorf("checking repo status: %w", err)
		}
		if dirty && !force {
			return fmt.Errorf(
				"golden copy has uncommitted changes.\n" +
					"These changes will be included in the workspace clone.\n" +
					"Use --force to proceed anyway")
		}

		// Get CoW cloner
		cloner, err := clone.NewCloner(goldenRoot)
		if err != nil {
			return err
		}

		// Get current commit
		commit, _ := gitpkg.CurrentCommit(goldenRoot)

		branch, _ := cmd.Flags().GetString("branch")
		opts := workspace.CreateOpts{
			Branch:       branch,
			GoldenCommit: commit,
		}

		info, err := workspace.Create(goldenRoot, cfg, cloner, opts)
		if err != nil {
			return err
		}

		// Run post-clone hook
		if err := hooks.Run(info.Path, "post-clone"); err != nil {
			// Clean up on hook failure
			os.RemoveAll(info.Path)
			return fmt.Errorf("post-clone hook failed: %w\nWorkspace cleaned up", err)
		}

		// Checkout branch if specified
		if branch != "" {
			if err := gitpkg.Checkout(info.Path, branch, true); err != nil {
				// Don't clean up — clone succeeded, branch is secondary
				fmt.Fprintf(os.Stderr, "Warning: branch checkout failed: %v\n", err)
			}
			info.Branch = branch
		}

		// Output result
		jsonOut, _ := cmd.Flags().GetBool("json")
		if jsonOut {
			data, _ := json.MarshalIndent(info, "", "  ")
			fmt.Println(string(data))
		} else {
			fmt.Printf("Workspace created: %s\n", info.ID)
			fmt.Printf("Path: %s\n", info.Path)
			if branch != "" {
				fmt.Printf("Branch: %s\n", branch)
			}
		}

		return nil
	},
}

func getProjectName(repoRoot string) string {
	return filepath.Base(repoRoot)
}

func init() {
	createCmd.Flags().String("branch", "", "Branch to create/checkout in the workspace")
	createCmd.Flags().Bool("force", false, "Proceed even if golden copy has uncommitted changes")
	createCmd.Flags().Bool("json", false, "Output workspace info as JSON")
	rootCmd.AddCommand(createCmd)
}
```

Note: add `"path/filepath"` to the imports in the file.

**Step 2: Build and verify**

Run:
```bash
go build -o grove ./cmd/grove
```

Expected: builds without errors.

**Step 3: Commit**

```bash
git add cmd/grove/create.go
git commit -m "feat: add grove create command"
```

---

### Task 9: `grove destroy` Command

**Files:**
- Create: `cmd/grove/destroy.go`

**Step 1: Write the destroy command**

Create `cmd/grove/destroy.go`:

```go
package main

import (
	"fmt"
	"os"

	"github.com/AmpInc/grove/internal/config"
	gitpkg "github.com/AmpInc/grove/internal/git"
	"github.com/AmpInc/grove/internal/workspace"
	"github.com/spf13/cobra"
)

var destroyCmd = &cobra.Command{
	Use:   "destroy <id|path>",
	Short: "Remove a workspace",
	Long:  `Removes a workspace directory. Optionally pushes the branch first.`,
	Args:  cobra.MaximumNArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		cwd, err := os.Getwd()
		if err != nil {
			return err
		}

		goldenRoot, err := config.FindGroveRoot(cwd)
		if err != nil {
			return err
		}

		cfg, err := config.Load(goldenRoot)
		if err != nil {
			return err
		}

		projectName := getProjectName(goldenRoot)
		cfg.WorkspaceDir = config.ExpandWorkspaceDir(cfg.WorkspaceDir, projectName)

		all, _ := cmd.Flags().GetBool("all")
		push, _ := cmd.Flags().GetBool("push")

		if all {
			list, err := workspace.List(cfg)
			if err != nil {
				return err
			}
			if len(list) == 0 {
				fmt.Println("No workspaces to destroy.")
				return nil
			}
			for _, ws := range list {
				if push && ws.Branch != "" {
					gitpkg.Push(ws.Path, ws.Branch)
				}
				if err := workspace.Destroy(cfg, ws.ID); err != nil {
					fmt.Fprintf(os.Stderr, "Warning: failed to destroy %s: %v\n", ws.ID, err)
					continue
				}
				fmt.Printf("Destroyed: %s\n", ws.ID)
			}
			return nil
		}

		if len(args) == 0 {
			return fmt.Errorf("provide a workspace ID or path, or use --all")
		}

		idOrPath := args[0]
		if push {
			info, err := workspace.Get(cfg, idOrPath)
			if err == nil && info.Branch != "" {
				gitpkg.Push(info.Path, info.Branch)
			}
		}

		if err := workspace.Destroy(cfg, idOrPath); err != nil {
			return err
		}
		fmt.Printf("Destroyed: %s\n", idOrPath)
		return nil
	},
}

func init() {
	destroyCmd.Flags().Bool("all", false, "Destroy all workspaces")
	destroyCmd.Flags().Bool("push", false, "Push branch before destroying")
	rootCmd.AddCommand(destroyCmd)
}
```

Note: this requires adding a `Push` function to `internal/git/git.go`:

```go
// Push pushes a branch to origin.
func Push(path, branch string) error {
	cmd := exec.Command("git", "-C", path, "push", "-u", "origin", branch)
	return cmd.Run()
}
```

**Step 2: Build and verify**

Run:
```bash
go build -o grove ./cmd/grove
```

Expected: builds without errors.

**Step 3: Commit**

```bash
git add cmd/grove/destroy.go internal/git/git.go
git commit -m "feat: add grove destroy command with --all and --push flags"
```

---

### Task 10: `grove list` Command

**Files:**
- Create: `cmd/grove/list.go`

**Step 1: Write the list command**

Create `cmd/grove/list.go`:

```go
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"text/tabwriter"
	"time"

	"github.com/AmpInc/grove/internal/config"
	"github.com/AmpInc/grove/internal/workspace"
	"github.com/spf13/cobra"
)

var listCmd = &cobra.Command{
	Use:   "list",
	Short: "List active workspaces",
	RunE: func(cmd *cobra.Command, args []string) error {
		cwd, err := os.Getwd()
		if err != nil {
			return err
		}

		goldenRoot, err := config.FindGroveRoot(cwd)
		if err != nil {
			return err
		}

		cfg, err := config.Load(goldenRoot)
		if err != nil {
			return err
		}

		projectName := getProjectName(goldenRoot)
		cfg.WorkspaceDir = config.ExpandWorkspaceDir(cfg.WorkspaceDir, projectName)

		workspaces, err := workspace.List(cfg)
		if err != nil {
			return err
		}

		jsonOut, _ := cmd.Flags().GetBool("json")
		if jsonOut {
			data, _ := json.MarshalIndent(workspaces, "", "  ")
			fmt.Println(string(data))
			return nil
		}

		if len(workspaces) == 0 {
			fmt.Println("No active workspaces.")
			return nil
		}

		w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
		fmt.Fprintln(w, "ID\tBRANCH\tCREATED\tPATH")
		for _, ws := range workspaces {
			age := formatAge(ws.CreatedAt)
			fmt.Fprintf(w, "%s\t%s\t%s\t%s\n", ws.ID, ws.Branch, age, ws.Path)
		}
		w.Flush()
		return nil
	},
}

func formatAge(t time.Time) string {
	d := time.Since(t)
	switch {
	case d < time.Minute:
		return "just now"
	case d < time.Hour:
		return fmt.Sprintf("%dm ago", int(d.Minutes()))
	case d < 24*time.Hour:
		return fmt.Sprintf("%dh ago", int(d.Hours()))
	default:
		return fmt.Sprintf("%dd ago", int(d.Hours()/24))
	}
}

func init() {
	listCmd.Flags().Bool("json", false, "Output workspace list as JSON")
	rootCmd.AddCommand(listCmd)
}
```

**Step 2: Build and verify**

Run:
```bash
go build -o grove ./cmd/grove && ./grove list --help
```

Expected: builds, help text shows flags.

**Step 3: Commit**

```bash
git add cmd/grove/list.go
git commit -m "feat: add grove list command with table and JSON output"
```

---

### Task 11: `grove status` Command

**Files:**
- Create: `cmd/grove/status.go`

**Step 1: Write the status command**

Create `cmd/grove/status.go`:

```go
package main

import (
	"fmt"
	"os"

	"github.com/AmpInc/grove/internal/config"
	gitpkg "github.com/AmpInc/grove/internal/git"
	"github.com/AmpInc/grove/internal/workspace"
	"github.com/spf13/cobra"
)

var statusCmd = &cobra.Command{
	Use:   "status",
	Short: "Show golden copy info and workspace summary",
	RunE: func(cmd *cobra.Command, args []string) error {
		cwd, err := os.Getwd()
		if err != nil {
			return err
		}

		goldenRoot, err := config.FindGroveRoot(cwd)
		if err != nil {
			return err
		}

		cfg, err := config.Load(goldenRoot)
		if err != nil {
			return err
		}

		projectName := getProjectName(goldenRoot)
		cfg.WorkspaceDir = config.ExpandWorkspaceDir(cfg.WorkspaceDir, projectName)

		branch, _ := gitpkg.CurrentBranch(goldenRoot)
		commit, _ := gitpkg.CurrentCommit(goldenRoot)
		dirty, _ := gitpkg.IsDirty(goldenRoot)

		statusStr := "clean"
		if dirty {
			statusStr = "dirty (uncommitted changes)"
		}

		isWs := workspace.IsWorkspace(goldenRoot)
		if isWs {
			fmt.Println("You are inside a grove workspace.")
			fmt.Println()
		}

		fmt.Printf("Golden copy: %s\n", goldenRoot)
		fmt.Printf("Branch:      %s\n", branch)
		fmt.Printf("Commit:      %s\n", commit)
		fmt.Printf("Status:      %s\n", statusStr)
		fmt.Println()

		workspaces, _ := workspace.List(cfg)
		fmt.Printf("Workspaces:  %d / %d (max)\n", len(workspaces), cfg.MaxWorkspaces)
		fmt.Printf("Directory:   %s\n", cfg.WorkspaceDir)

		return nil
	},
}

func init() {
	rootCmd.AddCommand(statusCmd)
}
```

**Step 2: Build and verify**

Run:
```bash
go build -o grove ./cmd/grove
```

Expected: builds without errors.

**Step 3: Commit**

```bash
git add cmd/grove/status.go
git commit -m "feat: add grove status command"
```

---

### Task 12: `grove update` Command

**Files:**
- Create: `cmd/grove/update.go`

**Step 1: Write the update command**

Create `cmd/grove/update.go`:

```go
package main

import (
	"fmt"
	"os"
	"os/exec"

	"github.com/AmpInc/grove/internal/config"
	gitpkg "github.com/AmpInc/grove/internal/git"
	"github.com/spf13/cobra"
)

var updateCmd = &cobra.Command{
	Use:   "update",
	Short: "Pull latest and rebuild the golden copy",
	Long:  `Convenience command to refresh the golden copy: git pull + warmup command.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		cwd, err := os.Getwd()
		if err != nil {
			return err
		}

		goldenRoot, err := config.FindGroveRoot(cwd)
		if err != nil {
			return err
		}

		cfg, err := config.Load(goldenRoot)
		if err != nil {
			return err
		}

		fmt.Println("Pulling latest...")
		if err := gitpkg.Pull(goldenRoot); err != nil {
			return fmt.Errorf("git pull failed: %w", err)
		}

		if cfg.WarmupCommand != "" {
			fmt.Printf("Running warmup: %s\n", cfg.WarmupCommand)
			warmup := exec.Command("sh", "-c", cfg.WarmupCommand)
			warmup.Dir = goldenRoot
			warmup.Stdout = os.Stdout
			warmup.Stderr = os.Stderr
			if err := warmup.Run(); err != nil {
				return fmt.Errorf("warmup command failed: %w", err)
			}
		}

		commit, _ := gitpkg.CurrentCommit(goldenRoot)
		fmt.Printf("Golden copy updated to %s\n", commit)
		return nil
	},
}

func init() {
	rootCmd.AddCommand(updateCmd)
}
```

**Step 2: Build and verify**

Run:
```bash
go build -o grove ./cmd/grove && ./grove update --help
```

Expected: builds, shows help text.

**Step 3: Commit**

```bash
git add cmd/grove/update.go
git commit -m "feat: add grove update command"
```

---

### Task 13: End-to-End Integration Test

**Files:**
- Create: `test/e2e_test.go`

**Step 1: Write the integration test**

Create `test/e2e_test.go`:

```go
package test

import (
	"encoding/json"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"testing"

	"github.com/AmpInc/grove/internal/workspace"
)

func buildGrove(t *testing.T) string {
	t.Helper()
	binary := filepath.Join(t.TempDir(), "grove")
	cmd := exec.Command("go", "build", "-o", binary, "./cmd/grove")
	// Build from the repo root
	cmd.Dir = filepath.Join(repoRoot(t))
	out, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("failed to build grove: %s\n%s", err, out)
	}
	return binary
}

func repoRoot(t *testing.T) string {
	t.Helper()
	// Walk up from test/ to find go.mod
	dir, _ := os.Getwd()
	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			t.Fatal("could not find repo root")
		}
		dir = parent
	}
}

func setupTestRepo(t *testing.T) string {
	t.Helper()
	dir := t.TempDir()
	run(t, dir, "git", "init")
	run(t, dir, "git", "config", "user.email", "test@test.com")
	run(t, dir, "git", "config", "user.name", "Test")
	os.WriteFile(filepath.Join(dir, "main.go"), []byte("package main\n"), 0644)
	os.MkdirAll(filepath.Join(dir, "build"), 0755)
	os.WriteFile(filepath.Join(dir, "build", "output.bin"), []byte("compiled"), 0644)
	run(t, dir, "git", "add", "main.go")
	run(t, dir, "git", "commit", "-m", "init")
	return dir
}

func run(t *testing.T, dir, name string, args ...string) string {
	t.Helper()
	cmd := exec.Command(name, args...)
	cmd.Dir = dir
	out, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("%s %v failed: %s\n%s", name, args, err, out)
	}
	return strings.TrimSpace(string(out))
}

func grove(t *testing.T, binary, dir string, args ...string) string {
	t.Helper()
	cmd := exec.Command(binary, args...)
	cmd.Dir = dir
	out, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("grove %v failed: %s\n%s", args, err, out)
	}
	return strings.TrimSpace(string(out))
}

func TestFullLifecycle(t *testing.T) {
	if runtime.GOOS != "darwin" {
		t.Skip("APFS tests only run on macOS")
	}

	binary := buildGrove(t)
	repo := setupTestRepo(t)

	// grove init
	out := grove(t, binary, repo, "init")
	if !strings.Contains(out, "Grove initialized") {
		t.Fatalf("unexpected init output: %s", out)
	}

	// Verify .grove/config.json exists
	if _, err := os.Stat(filepath.Join(repo, ".grove", "config.json")); err != nil {
		t.Fatal("config.json not created")
	}

	// grove create --json --branch test-feature
	out = grove(t, binary, repo, "create", "--json", "--branch", "test-feature")
	var info workspace.Info
	if err := json.Unmarshal([]byte(out), &info); err != nil {
		t.Fatalf("invalid JSON output: %s\n%s", err, out)
	}
	if info.ID == "" || info.Path == "" {
		t.Fatal("missing ID or Path in output")
	}

	// Verify source files in workspace
	data, err := os.ReadFile(filepath.Join(info.Path, "main.go"))
	if err != nil {
		t.Fatal("main.go not in workspace")
	}
	if string(data) != "package main\n" {
		t.Error("main.go content mismatch")
	}

	// Verify gitignored build artifacts are cloned
	data, err = os.ReadFile(filepath.Join(info.Path, "build", "output.bin"))
	if err != nil {
		t.Fatal("build/output.bin not in workspace — gitignored files not cloned")
	}
	if string(data) != "compiled" {
		t.Error("build artifact content mismatch")
	}

	// Verify CoW isolation — modify workspace, check golden unchanged
	os.WriteFile(filepath.Join(info.Path, "main.go"), []byte("modified\n"), 0644)
	origData, _ := os.ReadFile(filepath.Join(repo, "main.go"))
	if string(origData) != "package main\n" {
		t.Error("golden copy was modified — CoW isolation broken")
	}

	// grove list
	out = grove(t, binary, repo, "list")
	if !strings.Contains(out, info.ID) {
		t.Errorf("list output doesn't contain workspace ID: %s", out)
	}

	// grove status
	out = grove(t, binary, repo, "status")
	if !strings.Contains(out, "1 / ") {
		t.Errorf("status doesn't show 1 workspace: %s", out)
	}

	// grove destroy
	grove(t, binary, repo, "destroy", info.ID)
	if _, err := os.Stat(info.Path); !os.IsNotExist(err) {
		t.Error("workspace not cleaned up after destroy")
	}

	// grove list should be empty
	out = grove(t, binary, repo, "list")
	if strings.Contains(out, info.ID) {
		t.Error("destroyed workspace still in list")
	}
}

func TestPostCloneHook(t *testing.T) {
	if runtime.GOOS != "darwin" {
		t.Skip("APFS tests only run on macOS")
	}

	binary := buildGrove(t)
	repo := setupTestRepo(t)

	grove(t, binary, repo, "init")

	// Create a post-clone hook that creates a marker file
	hookPath := filepath.Join(repo, ".grove", "hooks", "post-clone")
	os.WriteFile(hookPath, []byte("#!/bin/bash\ntouch hook-executed\n"), 0755)

	out := grove(t, binary, repo, "create", "--json")
	var info workspace.Info
	json.Unmarshal([]byte(out), &info)

	if _, err := os.Stat(filepath.Join(info.Path, "hook-executed")); err != nil {
		t.Error("post-clone hook did not run")
	}

	// Cleanup
	grove(t, binary, repo, "destroy", "--all")
}

func TestDirtyGoldenCopy(t *testing.T) {
	if runtime.GOOS != "darwin" {
		t.Skip("APFS tests only run on macOS")
	}

	binary := buildGrove(t)
	repo := setupTestRepo(t)

	grove(t, binary, repo, "init", "--force") // init forces past dirty check

	// Make golden copy dirty
	os.WriteFile(filepath.Join(repo, "dirty.txt"), []byte("wip"), 0644)

	// create should fail without --force
	cmd := exec.Command(binary, "create")
	cmd.Dir = repo
	out, err := cmd.CombinedOutput()
	if err == nil {
		t.Fatal("expected error for dirty golden copy")
	}
	if !strings.Contains(string(out), "uncommitted changes") {
		t.Errorf("expected uncommitted changes error, got: %s", out)
	}

	// create should succeed with --force
	grove(t, binary, repo, "create", "--force")

	// Cleanup
	grove(t, binary, repo, "destroy", "--all")
}
```

**Step 2: Run the tests**

Run:
```bash
go test ./test/... -v -count=1
```

Expected: all tests PASS.

**Step 3: Commit**

```bash
git add test/
git commit -m "test: add end-to-end integration tests for full lifecycle"
```

---

### Task 14: Run All Tests + Final Verification

**Step 1: Run the full test suite**

Run:
```bash
go test ./... -v -count=1
```

Expected: all packages pass.

**Step 2: Build the final binary**

Run:
```bash
go build -o grove ./cmd/grove
```

Expected: clean build.

**Step 3: Manual smoke test**

Run:
```bash
cd $(mktemp -d) && git init && git commit --allow-empty -m "init"
grove init
grove status
grove create --branch test --json
grove list
grove destroy --all
```

Expected: each command works as designed.

**Step 4: Clean up binary from repo, commit**

```bash
rm -f grove
echo "grove" >> .gitignore
git add .gitignore
git commit -m "chore: add built binary to gitignore"
```
